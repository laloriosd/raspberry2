# -*- coding: utf-8 -*-
"""prueba5streamlit

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1p70LH_66xUqMA8b0gUKxA7MvT0RZoIIC
"""

# app.py
import streamlit as st
import pandas as pd
import unicodedata
import difflib
from datetime import datetime
from dateutil.relativedelta import relativedelta
import matplotlib
matplotlib.use("Agg")   # <-- backend compatible con Streamlit Cloud
import matplotlib.pyplot as plt
import base64
from io import BytesIO
import os

# ----------------------------
# Config
# ----------------------------
st.set_page_config(page_title="Altas y Cambios de Beneficiarios", layout="wide")

# Ruta por defecto del logo (la que tienes en /mnt/data)
RUTA_LOGO_POR_DEFECTO = "/mnt/data/f2f98b15-0813-4e3a-a6d8-6f26349204b4.png"

# ----------------------------
# Utils de limpieza (tu cÃ³digo original)
# ----------------------------
def limpiar_texto(texto):
    if pd.isna(texto):
        return ""
    texto = str(texto).strip()
    texto = ''.join(c for c in unicodedata.normalize('NFKD', texto) if not unicodedata.combining(c))
    texto = texto.replace("Ã‘", "Â¥").replace("Ã±", "Â¥")
    return texto.upper()

def limpiar_certificado(valor):
    if pd.isna(valor):
        return ""
    try:
        return str(int(float(valor)))
    except:
        return str(valor).strip()

def limpiar_fecha_str(valor):
    if pd.isna(valor) or str(valor).strip() == "":
        return ""
    try:
        fecha = pd.to_datetime(str(valor).strip(), errors="coerce", dayfirst=False)
        if pd.isna(fecha):
            fecha = pd.to_datetime(str(valor).strip(), errors="coerce", dayfirst=True)
        if pd.isna(fecha):
            return ""
        return fecha.strftime("%Y-%m-%d")
    except:
        return ""

def calcular_edad(fecha):
    if pd.isna(fecha) or fecha == "":
        return None
    try:
        fecha = pd.to_datetime(fecha)
        hoy = datetime.today()
        edad = hoy.year - fecha.year - ((hoy.month, hoy.day) < (fecha.month, fecha.day))
        return edad
    except:
        return None

def nombre_completo(df):
    return (
        df["NOMBRE"].astype(str).str.strip() + " " +
        df["APELLIDO_PATERNO"].astype(str).str.strip() + " " +
        df["APELLIDO_MATERNO"].astype(str).str.strip()
    ).str.replace(r"\s+", " ", regex=True)

def crear_ids(df):
    # Mantengo todas las ids que usaste en tu cÃ³digo original
    df["CERTIFICADO_NOMBRE"] = df["CERTIFICADO"].astype(str) + "_" + df["NOMBRE"].astype(str)
    df["CERTIFICADO_APELLIDO_PATERNO"] = df["CERTIFICADO"].astype(str) + "_" + df["APELLIDO_PATERNO"].astype(str)
    df["CERTIFICADO_APELLIDO_MATERNO"] = df["CERTIFICADO"].astype(str) + "_" + df["APELLIDO_MATERNO"].astype(str)
    df["CERTIFICADO_PARENTESCO"] = df["CERTIFICADO"].astype(str) + "_" + df["PARENTESCO"].astype(str)
    df["CERTIFICADO_FECHA"] = df["CERTIFICADO"].astype(str) + "_" + df["FECHA_DE_NACIMIENTO_BENEFICIARIO"].astype(str)
    df["CERTIFICADO_NOMBRE_COMPLETO"] = df["CERTIFICADO"].astype(str) + "_" + df["NOMBRE_COMPLETO"].astype(str)
    df["CERTIFICADO_NOMBRE_FECHA"] = df["CERTIFICADO"].astype(str) + "_" + df["NOMBRE"].astype(str) + "_" + df["FECHA_DE_NACIMIENTO_BENEFICIARIO"].astype(str)
    df["CERTIFICADO_AP_PAT_FECHA"] = df["CERTIFICADO"].astype(str) + "_" + df["APELLIDO_PATERNO"].astype(str) + "_" + df["FECHA_DE_NACIMIENTO_BENEFICIARIO"].astype(str)
    df["CERTIFICADO_AP_MAT_FECHA"] = df["CERTIFICADO"].astype(str) + "_" + df["APELLIDO_MATERNO"].astype(str) + "_" + df["FECHA_DE_NACIMIENTO_BENEFICIARIO"].astype(str)
    df["CERTIFICADO_NOMBRE_AP_PAT"] = df["CERTIFICADO"].astype(str) + "_" + df["NOMBRE"].astype(str) + "_" + df["APELLIDO_PATERNO"].astype(str)
    df["CERTIFICADO_NOMBRE_AP_MAT"] = df["CERTIFICADO"].astype(str) + "_" + df["NOMBRE"].astype(str) + "_" + df["APELLIDO_MATERNO"].astype(str)

def similitud_caracteres(a, b):
    a = limpiar_texto(a)
    b = limpiar_texto(b)
    if not a or not b:
        return 0.0
    return difflib.SequenceMatcher(None, a, b).ratio()

# ----------------------------
# Helper: header con logo y gradiente
# ----------------------------
def dibujar_header(logo_path=None, titulo="Altas y Cambios de Beneficiarios", subtitulo="Somos tu aliado en protecciÃ³n"):
    # intenta codificar el logo (si existe)
    img_tag = ""
    if logo_path and os.path.exists(logo_path):
        try:
            b64 = base64.b64encode(open(logo_path, "rb").read()).decode()
            img_tag = f'<img src="data:image/png;base64,{b64}" style="height:80px; margin-right:20px;"/>'
        except:
            img_tag = ""
    # HTML seguro para el header
    html = f"""
    <div style="background: linear-gradient(90deg, #0666a3, #27c3a8); padding: 18px; border-radius: 10px; display:flex; align-items:center;">
        <div style="flex:0 0 auto; display:flex; align-items:center;">
            {img_tag}
        </div>
        <div style="color: white; padding-left:10px;">
            <h1 style="color:white; margin:0; padding:0; font-size:28px;">{titulo}</h1>
            <div style="font-size:14px; opacity:0.95;">{subtitulo}</div>
        </div>
    </div>
    """
    st.markdown(html, unsafe_allow_html=True)

# ----------------------------
# UI: subir archivos (ALTAS, BITACORA) y logo opcional
# ----------------------------
st.write("")  # espacio
# Intento cargar logo por defecto; si no existe, el header se muestra sin <img>
logo_subido = st.file_uploader("ðŸ“Ž (Opcional) Subir logo de la empresa (png/jpg)", type=["png", "jpg", "jpeg"], key="logo")
if logo_subido:
    # guardamos temporalmente para usarlo en el header
    ruta_logo_temporal = "/tmp/logo_streamlit_upload.png"
    with open(ruta_logo_temporal, "wb") as f:
        f.write(logo_subido.getbuffer())
    dibujar_header(ruta_logo_temporal)
else:
    # intenta la ruta por defecto (la que me diste)
    if os.path.exists(RUTA_LOGO_POR_DEFECTO):
        dibujar_header(RUTA_LOGO_POR_DEFECTO)
    else:
        dibujar_header(None)

st.markdown("## Subir archivos para procesar")
archivo_semana = st.file_uploader("ðŸ“Œ Archivo de la semana (ALTAS)", type=["xlsx"], key="altas")
archivo_bitacora = st.file_uploader("ðŸ“˜ Archivo histÃ³rico (bitÃ¡cora)", type=["xlsx"], key="hist")

# ----------------------------
# Procesamiento: uso TU LÃ“GICA COMPLETA
# ----------------------------
if archivo_semana and archivo_bitacora:
    st.success("Archivos cargados correctamente. Procesandoâ€¦")

    # Leer archivos (como DataFrames)
    RUTA_BASE = "."  # para descargas / export (en deploy puede cambiar)
    altas = pd.read_excel(archivo_semana, skiprows=2)
    hist_raw = pd.read_excel(archivo_bitacora)

    # ==== limpiar histÃ³rico (igual que tu script) ====
    mapeo_columnas = {
        'NOMBRE': 'NOMBRE',
        'F. NAC': 'FECHA_DE_NACIMIENTO_BENEFICIARIO',
        'PARENTESCO': 'PARENTESCO',
        'APELLIDO PATERNO': 'APELLIDO_PATERNO',
        'APELLIDO MATERNO': 'APELLIDO_MATERNO',
        'CERT': 'CERTIFICADO'
    }
    hist_raw = hist_raw.rename(columns=mapeo_columnas)
    for col in hist_raw.columns:
        if hist_raw[col].dtype == "object":
            hist_raw[col] = hist_raw[col].apply(limpiar_texto)
    hist_raw["CERTIFICADO"] = hist_raw["CERTIFICADO"].apply(limpiar_certificado)
    hist_raw["FECHA_DE_NACIMIENTO_BENEFICIARIO"] = hist_raw["FECHA_DE_NACIMIENTO_BENEFICIARIO"].apply(limpiar_fecha_str)
    hist_raw["NOMBRE_COMPLETO"] = nombre_completo(hist_raw)
    hist = hist_raw.copy()

    # ==== limpiar ALTAS (igual a tu script) ====
    altas.columns = altas.columns.str.replace(' ', '_').str.upper()
    cols = altas.columns.tolist()
    if len(cols) > 14:
        cols[2] = "FECHA_DE_NACIMIENTO_EMPLEADO"
        cols[14] = "FECHA_DE_NACIMIENTO_BENEFICIARIO"
    altas.columns = cols

    altas["FECHA_DE_MOVIMIENTO"] = pd.to_datetime(altas.get("FECHA_DE_MOVIMIENTO"), errors="coerce")
    fecha_limite = datetime.today() - relativedelta(months=6)
    validas = altas["FECHA_DE_MOVIMIENTO"].notna().sum()
    if validas == 0:
        st.error("FECHA_DE_MOVIMIENTO no tiene fechas vÃ¡lidas. Revisa el archivo de ALTAS.")
    else:
        altas_6 = altas[altas["FECHA_DE_MOVIMIENTO"] >= fecha_limite].copy()
        altas_6 = altas_6.dropna(subset=["NOMBRE", "APELLIDO_PATERNO", "APELLIDO_MATERNO"]).copy()

        for col in ["NOMBRE", "APELLIDO_PATERNO", "APELLIDO_MATERNO", "PARENTESCO"]:
            if col in altas_6.columns:
                altas_6[col] = altas_6[col].apply(limpiar_texto)
        if "CERTIFICADO" in altas_6.columns:
            altas_6["CERTIFICADO"] = altas_6["CERTIFICADO"].apply(limpiar_certificado)
        if "FECHA_DE_NACIMIENTO_BENEFICIARIO" in altas_6.columns:
            altas_6["FECHA_DE_NACIMIENTO_BENEFICIARIO"] = altas_6["FECHA_DE_NACIMIENTO_BENEFICIARIO"].apply(limpiar_fecha_str)

        altas_6["NOMBRE_COMPLETO"] = nombre_completo(altas_6)
        altas_6["EDAD"] = altas_6["FECHA_DE_NACIMIENTO_BENEFICIARIO"].apply(calcular_edad)

        # exclusiones
        cond_hijo_excluir = (altas_6["PARENTESCO"].isin(["HIJO", "HIJA"]) & (altas_6["EDAD"] >= 21))
        cond_esposo_excluir = (altas_6["PARENTESCO"].isin(["ESPOSO", "ESPOSA"]) & (altas_6["EDAD"] >= 65))
        altas_6 = altas_6[~(cond_hijo_excluir | cond_esposo_excluir)].copy()

        # crear ids
        crear_ids(altas_6)
        crear_ids(hist)

        # clasificaciÃ³n robusta (mantengo EXACTAMENTE tu lÃ³gica)
        H = {col: set(hist[col]) for col in hist.columns if col.startswith("CERTIFICADO")}

        def clasificar_mejorado(row):
            cert = row["CERTIFICADO"]
            nombre_id = f"{cert}_{row['NOMBRE']}"
            nomcomp_id = f"{cert}_{row['NOMBRE_COMPLETO']}"
            fecha_id = f"{cert}_{row['FECHA_DE_NACIMIENTO_BENEFICIARIO']}"
            ap_pat_id = f"{cert}_{row['APELLIDO_PATERNO']}"
            ap_mat_id = f"{cert}_{row['APELLIDO_MATERNO']}"

            nombre_match = nombre_id in H.get("CERTIFICADO_NOMBRE", set())
            nomcomp_match = nomcomp_id in H.get("CERTIFICADO_NOMBRE_COMPLETO", set())
            fecha_match = fecha_id in H.get("CERTIFICADO_FECHA", set())
            ap_pat_match = ap_pat_id in H.get("CERTIFICADO_APELLIDO_PATERNO", set())
            ap_mat_match = ap_mat_id in H.get("CERTIFICADO_APELLIDO_MATERNO", set())

            hist_cert = hist[hist["CERTIFICADO"] == cert]
            fuzzy_name_match = False
            if not hist_cert.empty:
                for h_nom in hist_cert["NOMBRE"].dropna().unique():
                    if similitud_caracteres(row["NOMBRE"], h_nom) >= 0.8:
                        fuzzy_name_match = True
                        break

            if nombre_match and nomcomp_match and fecha_match and ap_pat_match and ap_mat_match:
                return "YA_EXISTE"
            if fuzzy_name_match and (ap_pat_match or ap_mat_match or fecha_match or nomcomp_match):
                return "CAMBIO"
            if nomcomp_match and not fecha_match:
                return "CAMBIO"
            if fecha_match and not nomcomp_match:
                return "CAMBIO"
            if ap_pat_match and ap_mat_match and not fecha_match:
                return "ALTA"
            if not (nombre_match or nomcomp_match or fecha_match or ap_pat_match or ap_mat_match or fuzzy_name_match):
                return "ALTA"
            return "REVISION"

        altas_6["TIPO_REGISTRO_ROBUSTO"] = altas_6.apply(clasificar_mejorado, axis=1)

        # separar
        ya_existe_df = altas_6[altas_6["TIPO_REGISTRO_ROBUSTO"] == "YA_EXISTE"].copy()
        altas_df     = altas_6[altas_6["TIPO_REGISTRO_ROBUSTO"] == "ALTA"].copy()
        cambios_df   = altas_6[altas_6["TIPO_REGISTRO_ROBUSTO"] == "CAMBIO"].copy()
        revision_df  = altas_6[altas_6["TIPO_REGISTRO_ROBUSTO"] == "REVISION"].copy()

        # detectar diferencias (idÃ©ntico a tu script)
        hist_key = hist[[
            "CERTIFICADO","NOMBRE","APELLIDO_PATERNO","APELLIDO_MATERNO",
            "PARENTESCO","FECHA_DE_NACIMIENTO_BENEFICIARIO"
        ]]

        def aplicar_limpieza_new(df, campos):
            for c in campos:
                nc = f"{c}_NEW"
                if nc in df.columns:
                    if c != "FECHA_DE_NACIMIENTO_BENEFICIARIO":
                        df[nc] = df[nc].apply(limpiar_texto)
                    else:
                        df[nc] = df[nc].apply(limpiar_fecha_str)

        def marcar_diferencias(row):
            diffs = []
            campos = ["NOMBRE","APELLIDO_PATERNO","APELLIDO_MATERNO","PARENTESCO","FECHA_DE_NACIMIENTO_BENEFICIARIO"]
            for c in campos:
                old_val = row.get(f"{c}_OLD","")
                new_val = row.get(f"{c}_NEW","")
                if str(old_val).strip() != str(new_val).strip():
                    diffs.append((c, old_val, new_val))
            dice = "; ".join([f"{c}:{o}" for c,o,_ in diffs])
            debe = "; ".join([f"{c}:{n}" for c,_,n in diffs])
            return pd.Series({"DICE": dice, "DEBE DECIR": debe})

        # CAMBIOS
        c_merge = cambios_df.merge(hist_key, on="CERTIFICADO", suffixes=("_NEW","_OLD"), how="left")
        aplicar_limpieza_new(c_merge, ["NOMBRE","APELLIDO_PATERNO","APELLIDO_MATERNO","PARENTESCO","FECHA_DE_NACIMIENTO_BENEFICIARIO"])
        diff_cols = c_merge.apply(marcar_diferencias, axis=1)
        c_merge = pd.concat([c_merge, diff_cols], axis=1)

        def old_vacio(row):
            campos = ["NOMBRE","APELLIDO_PATERNO","APELLIDO_MATERNO","PARENTESCO","FECHA_DE_NACIMIENTO_BENEFICIARIO"]
            return all((str(row.get(f"{c}_OLD","")).strip() == "" for c in campos))

        def contar_diferencias(row):
            campos = ["NOMBRE","APELLIDO_PATERNO","APELLIDO_MATERNO","PARENTESCO","FECHA_DE_NACIMIENTO_BENEFICIARIO"]
            count = 0
            for c in campos:
                if str(row.get(f"{c}_OLD","")).strip() != str(row.get(f"{c}_NEW","")).strip():
                    count += 1
            return count

        def reclasificar_cambios(row):
            if old_vacio(row):
                return "ALTA_RECLASIFICADA"
            return "ALTA_RECLASIFICADA" if contar_diferencias(row) >= 3 else "CAMBIO_VALIDADO"

        c_merge["RECLASIFICACION"] = c_merge.apply(reclasificar_cambios, axis=1)
        cambios_validados = c_merge[c_merge["RECLASIFICACION"]=="CAMBIO_VALIDADO"].copy()
        altas_reclasificadas = c_merge[c_merge["RECLASIFICACION"]=="ALTA_RECLASIFICADA"].copy()

        # REVISION
        rev_merge = revision_df.merge(hist_key, on="CERTIFICADO", suffixes=("_NEW","_OLD"), how="left")
        aplicar_limpieza_new(rev_merge, ["NOMBRE","APELLIDO_PATERNO","APELLIDO_MATERNO","PARENTESCO","FECHA_DE_NACIMIENTO_BENEFICIARIO"])
        rev_diff = rev_merge.apply(marcar_diferencias, axis=1)
        revision_df = pd.concat([rev_merge, rev_diff], axis=1)
        revision_df["RECLASIFICACION"] = revision_df.apply(
            lambda r: "ALTA_RECLASIFICADA" if old_vacio(r) else "REVISION_VALIDADA",
            axis=1
        )
        altas_desde_revision = revision_df[revision_df["RECLASIFICACION"]=="ALTA_RECLASIFICADA"].copy()
        revision_df = revision_df[revision_df["RECLASIFICACION"]=="REVISION_VALIDADA"].copy()

        # enriquecer con pÃ³liza
        for col in ["POLIZA","SUB"]:
            if col not in hist.columns:
                hist[col] = ""
        hist_extra = hist[["CERTIFICADO","POLIZA","SUB"]].copy()
        hist_extra.columns = ["CERTIFICADO","NUMERO POLIZA","SUBGRUPO"]

        cambios_validados = cambios_validados.merge(hist_extra, on="CERTIFICADO", how="left")
        altas_df = altas_df.merge(hist_extra, on="CERTIFICADO", how="left")
        altas_reclasificadas = altas_reclasificadas.merge(hist_extra, on="CERTIFICADO", how="left")
        altas_desde_revision = altas_desde_revision.merge(hist_extra, on="CERTIFICADO", how="left")
        ya_existe_df = ya_existe_df.merge(hist_extra, on="CERTIFICADO", how="left")
        revision_df = revision_df.merge(hist_extra, on="CERTIFICADO", how="left")

        # ALTAS finales
        altas_reclasificadas_fmt = altas_reclasificadas[[
            "APELLIDO_PATERNO_NEW","APELLIDO_MATERNO_NEW","NOMBRE_NEW",
            "CERTIFICADO","PARENTESCO_NEW","SUBGRUPO","NUMERO POLIZA"
        ]].copy().rename(columns={
            "APELLIDO_PATERNO_NEW":"APELLIDO_PATERNO",
            "APELLIDO_MATERNO_NEW":"APELLIDO_MATERNO",
            "NOMBRE_NEW":"NOMBRE",
            "PARENTESCO_NEW":"PARENTESCO"
        })

        altas_revision_fmt = altas_desde_revision[[
            "APELLIDO_PATERNO_NEW","APELLIDO_MATERNO_NEW","NOMBRE_NEW",
            "CERTIFICADO","PARENTESCO_NEW","SUBGRUPO","NUMERO POLIZA"
        ]].copy().rename(columns={
            "APELLIDO_PATERNO_NEW":"APELLIDO_PATERNO",
            "APELLIDO_MATERNO_NEW":"APELLIDO_MATERNO",
            "NOMBRE_NEW":"NOMBRE",
            "PARENTESCO_NEW":"PARENTESCO"
        })

        altas_finales = pd.concat([
            altas_df[["APELLIDO_PATERNO","APELLIDO_MATERNO","NOMBRE","CERTIFICADO","PARENTESCO","SUBGRUPO","NUMERO POLIZA"]],
            altas_reclasificadas_fmt,
            altas_revision_fmt
        ], ignore_index=True)

        # CAMBIOS final
        cambios_final = cambios_validados[[
            "APELLIDO_PATERNO_NEW","APELLIDO_MATERNO_NEW","NOMBRE_NEW",
            "CERTIFICADO","PARENTESCO_NEW","SUBGRUPO","DICE","DEBE DECIR","NUMERO POLIZA"
        ]].copy().rename(columns={
            "APELLIDO_PATERNO_NEW":"APELLIDO_PATERNO",
            "APELLIDO_MATERNO_NEW":"APELLIDO_MATERNO",
            "NOMBRE_NEW":"NOMBRE",
            "PARENTESCO_NEW":"PARENTESCO"
        })

        # REVISION final
        revision_out = revision_df[[
            "APELLIDO_PATERNO_NEW","APELLIDO_MATERNO_NEW","NOMBRE_NEW",
            "CERTIFICADO","PARENTESCO_NEW","SUBGRUPO","DICE","DEBE DECIR","NUMERO POLIZA"
        ]].copy().rename(columns={
            "APELLIDO_PATERNO_NEW":"APELLIDO_PATERNO",
            "APELLIDO_MATERNO_NEW":"APELLIDO_MATERNO",
            "NOMBRE_NEW":"NOMBRE",
            "PARENTESCO_NEW":"PARENTESCO"
        })

        # YA EXISTE final
        ya_existente_out = ya_existe_df[[
            "APELLIDO_PATERNO","APELLIDO_MATERNO","NOMBRE","CERTIFICADO","PARENTESCO","SUBGRUPO","NUMERO POLIZA"
        ]].copy()

        # eliminar duplicados
        subset_altas = ["CERTIFICADO","NOMBRE","APELLIDO_PATERNO","APELLIDO_MATERNO","PARENTESCO"]
        subset_cambios = ["CERTIFICADO","NOMBRE","APELLIDO_PATERNO","APELLIDO_MATERNO","PARENTESCO","DICE","DEBE DECIR"]
        subset_revision = ["CERTIFICADO","NOMBRE","APELLIDO_PATERNO","APELLIDO_MATERNO","PARENTESCO","DICE","DEBE DECIR"]

        ya_existente_out = ya_existente_out.drop_duplicates(subset=subset_altas)
        altas_finales = altas_finales.drop_duplicates(subset=subset_altas)
        cambios_final = cambios_final.drop_duplicates(subset=subset_cambios)
        revision_out = revision_out.drop_duplicates(subset=subset_revision)

        # EXPORTAR (descargas)
        def df_to_excel_bytes(df):
            output = BytesIO()
            df.to_excel(output, index=False)
            return output.getvalue()

        st.subheader("ðŸ“Š EstadÃ­sticas")

        counts = {
            "ALTAS": len(altas_finales),
            "CAMBIOS": len(cambios_final),
            "REVISION": len(revision_out)
        }

        # Graficos: mismo tamaÃ±o y lado a lado
        col1, col2 = st.columns(2)

        # Pie chart (izquierda)
        fig1, ax1 = plt.subplots(figsize=(5,4))
        ax1.pie(counts.values(), labels=counts.keys(), autopct="%1.1f%%")
        ax1.set_title("DistribuciÃ³n general")
        col1.pyplot(fig1)

        # Bar chart (derecha)
        fig2, ax2 = plt.subplots(figsize=(5,4))
        ax2.bar(["Cambios", "RevisiÃ³n"], [counts["CAMBIOS"], counts["REVISION"]])
        ax2.set_title("Cambios vs RevisiÃ³n")
        col2.pyplot(fig2)

        # Descargas
        st.subheader("ðŸ“¥ Descargar resultados")
        st.download_button("ðŸ“˜ ALTAS", df_to_excel_bytes(altas_finales), "ALTAS.xlsx")
        st.download_button("ðŸ“™ CAMBIOS", df_to_excel_bytes(cambios_final), "CAMBIOS.xlsx")
        st.download_button("ðŸ“— REVISIÃ“N", df_to_excel_bytes(revision_out), "REVISION.xlsx")
        st.download_button("ðŸ“• YA EXISTE", df_to_excel_bytes(ya_existente_out), "YA_EXISTE.xlsx")

        # Conteos mostrados
        st.markdown(f"- **YA_EXISTE:** {len(ya_existente_out)}")
        st.markdown(f"- **ALTAS (incluye reclasificadas):** {len(altas_finales)}")
        st.markdown(f"- **CAMBIOS (validados):** {len(cambios_final)}")
        st.markdown(f"- **REVISION:** {len(revision_out)}")

else:
    st.info("Sube ambos archivos para procesar: archivo de la semana (ALTAS) y archivo histÃ³rico (bitÃ¡cora).")

"""Now that the Streamlit code is saved to `app.py`, run the cell below to launch the Streamlit application. You will get a public URL to access your app."""